<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duke Chapel Marketing Analytics Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500&family=Montserrat:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    <style>
        :root {
            --duke-navy: #1a365d;
            --duke-blue: #2563eb;
            --duke-light-blue: #3b82f6;
            --duke-orange: #ea580c;
            --duke-yellow: #f59e0b;
            --duke-teal: #0891b2;
            --duke-green: #059669;
            --duke-purple: #7c3aed;
            --duke-brown: #a3a3a3;
            --duke-gray: #6b7280;
            --duke-light-gray: #f3f4f6;
            --duke-white: #ffffff;
            --duke-cream: #fefcf8;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--duke-navy) 0%, var(--duke-blue) 50%, var(--duke-light-blue) 100%);
            min-height: 100vh;
            color: #1f2937;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
            position: relative;
            padding: 40px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 24px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 50px rgba(0,0,0,0.2);
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 4px;
            background: linear-gradient(90deg, var(--duke-orange), var(--duke-yellow), var(--duke-teal));
            border-radius: 2px;
        }
        
        .header h1 {
            font-family: 'EB Garamond', Georgia, serif;
            font-size: 3.2rem;
            font-weight: 700;
            margin: 20px 0 15px 0;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.3);
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, #ffffff, #e2e8f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .header .subtitle {
            font-size: 1.3rem;
            opacity: 0.95;
            font-weight: 500;
            margin-bottom: 10px;
            color: var(--duke-cream);
        }
        
        .header .tagline {
            font-size: 1rem;
            opacity: 0.8;
            font-style: italic;
            font-weight: 300;
            color: #cbd5e1;
        }
        
        .upload-section {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 24px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.15);
            border: 2px dashed var(--duke-blue);
            transition: all 0.4s ease;
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
        }
        
        .upload-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--duke-blue), transparent);
        }
        
        .upload-section:hover {
            border-color: var(--duke-orange);
            transform: translateY(-3px);
            box-shadow: 0 25px 60px rgba(0,0,0,0.2);
        }
        
        .upload-area {
            text-align: center;
            padding: 40px 20px;
        }
        
        .upload-area h3 {
            font-family: 'EB Garamond', Georgia, serif;
            font-size: 1.9rem;
            color: var(--duke-navy);
            margin-bottom: 15px;
            font-weight: 700;
        }
        
        .upload-area.dragover {
            background: linear-gradient(135deg, #eff6ff, #dbeafe);
            border-radius: 20px;
            border-color: var(--duke-orange);
        }
        
        .file-input {
            display: none;
        }
        
        .upload-btn {
            background: linear-gradient(135deg, var(--duke-blue), var(--duke-navy));
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s ease;
            box-shadow: 0 10px 30px rgba(37, 99, 235, 0.3);
            font-family: 'Montserrat', sans-serif;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }
        
        .upload-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .upload-btn:hover::before {
            left: 100%;
        }
        
        .upload-btn:hover {
            background: linear-gradient(135deg, var(--duke-orange), var(--duke-yellow));
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(234, 88, 12, 0.4);
        }
        
        .file-list {
            margin-top: 25px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
        }
        
        .file-item {
            background: linear-gradient(135deg, #eff6ff, #dbeafe);
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 0.9rem;
            border: 2px solid var(--duke-blue);
            font-weight: 500;
            color: var(--duke-navy);
            box-shadow: 0 4px 15px rgba(37, 99, 235, 0.1);
            transition: all 0.3s ease;
        }
        
        .file-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(37, 99, 235, 0.2);
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 24px;
            padding: 35px;
            margin-bottom: 30px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .control-group label {
            font-weight: 700;
            color: var(--duke-navy);
            font-size: 0.95rem;
            font-family: 'Montserrat', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-group input, .control-group select {
            padding: 14px 18px;
            border: 2px solid #e5e7eb;
            border-radius: 15px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
            font-family: 'Montserrat', sans-serif;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: var(--duke-blue);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            transform: translateY(-1px);
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 24px;
            padding: 35px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.1);
            transition: all 0.4s ease;
            border: 1px solid rgba(37, 99, 235, 0.1);
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--duke-blue), var(--duke-orange), var(--duke-teal));
        }
        
        .card:hover {
            transform: translateY(-8px);
            box-shadow: 0 25px 60px rgba(0,0,0,0.15);
        }
        
        .card h3 {
            margin-bottom: 30px;
            color: var(--duke-navy);
            font-size: 1.6rem;
            font-weight: 700;
            font-family: 'EB Garamond', Georgia, serif;
            border-bottom: 3px solid var(--duke-blue);
            padding-bottom: 15px;
            position: relative;
        }
        
        .card h3::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 80px;
            height: 3px;
            background: linear-gradient(90deg, var(--duke-orange), var(--duke-yellow));
            border-radius: 2px;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric {
            text-align: center;
            padding: 25px 18px;
            background: linear-gradient(135deg, #eff6ff, #dbeafe);
            border-radius: 20px;
            border-left: 5px solid var(--duke-blue);
            position: relative;
            overflow: hidden;
            transition: all 0.4s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        
        .metric:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 12px 30px rgba(0,0,0,0.15);
        }
        
        .metric::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--duke-blue), var(--duke-orange));
        }
        
        .metric-value {
            font-size: 2.2rem;
            font-weight: 800;
            color: var(--duke-navy);
            margin-bottom: 10px;
            line-height: 1;
            font-family: 'Montserrat', sans-serif;
        }
        
        .metric-label {
            font-size: 0.9rem;
            color: var(--duke-gray);
            font-weight: 600;
            font-family: 'Montserrat', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .metric-change {
            font-size: 0.8rem;
            margin-top: 10px;
            font-weight: 700;
            font-family: 'Montserrat', sans-serif;
            padding: 4px 8px;
            border-radius: 12px;
            display: inline-block;
        }
        
        .metric-change.positive {
            color: var(--duke-green);
            background: rgba(5, 150, 105, 0.1);
        }
        
        .metric-change.negative {
            color: #dc2626;
            background: rgba(220, 38, 38, 0.1);
        }
        
        .metric-change.neutral {
            color: var(--duke-gray);
            background: rgba(107, 114, 128, 0.1);
        }
        
        .chart-container {
            width: 100%;
            height: 380px;
            margin-top: 25px;
            position: relative;
            background: rgba(255,255,255,0.5);
            border-radius: 16px;
            padding: 15px;
        }
        
        .table-container {
            overflow-x: auto;
            margin-top: 25px;
            border-radius: 20px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
            font-family: 'Montserrat', sans-serif;
        }
        
        th, td {
            padding: 18px 15px;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
        }
        
        th {
            background: linear-gradient(135deg, #eff6ff, #dbeafe);
            font-weight: 700;
            color: var(--duke-navy);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }
        
        tbody tr {
            transition: all 0.3s ease;
        }
        
        tbody tr:hover {
            background: linear-gradient(135deg, #f8fafc, #f1f5f9);
            transform: scale(1.01);
        }
        
        .section-header {
            background: linear-gradient(135deg, var(--duke-navy), var(--duke-blue));
            color: white;
            padding: 35px;
            border-radius: 24px;
            margin: 50px 0 30px 0;
            text-align: center;
            font-size: 2rem;
            font-weight: 700;
            font-family: 'EB Garamond', Georgia, serif;
            box-shadow: 0 20px 50px rgba(26, 54, 93, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .section-header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            transform: rotate(45deg);
            animation: shimmer 4s infinite;
        }
        
        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            50% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }
        
        .loading {
            text-align: center;
            padding: 60px;
            color: var(--duke-gray);
            font-size: 1.2rem;
            font-family: 'Montserrat', sans-serif;
        }
        
        .error {
            background: linear-gradient(135deg, #fef2f2, #fee2e2);
            color: #dc2626;
            padding: 25px;
            border-radius: 20px;
            margin: 20px 0;
            border-left: 5px solid #dc2626;
            font-weight: 600;
            font-family: 'Montserrat', sans-serif;
            box-shadow: 0 8px 25px rgba(220, 38, 38, 0.1);
        }
        
        #dateRangeInfo {
            background: linear-gradient(135deg, #eff6ff, #dbeafe);
            padding: 18px 25px;
            border-radius: 15px;
            border-left: 4px solid var(--duke-blue);
            font-size: 0.95rem;
            color: var(--duke-navy);
            font-weight: 500;
            margin-top: 20px;
            font-family: 'Montserrat', sans-serif;
            box-shadow: 0 4px 15px rgba(37, 99, 235, 0.1);
        }
        
        .data-overview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }
        
        .data-status-card {
            background: linear-gradient(135deg, #f8fafc, #f1f5f9);
            padding: 22px;
            border-radius: 20px;
            border-left: 4px solid var(--duke-blue);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        
        .data-status-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        
        .data-status-card h4 {
            margin: 0 0 10px 0;
            color: var(--duke-navy);
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
            font-size: 1.1rem;
        }
        
        .data-status-card p {
            margin: 0;
            font-size: 0.9rem;
            color: var(--duke-gray);
            font-family: 'Montserrat', sans-serif;
            font-weight: 500;
        }
        
        .data-status-card small {
            color: #9ca3af;
            font-size: 0.8rem;
            line-height: 1.4;
        }
        
        /* Tab styling improvements */
        .tab-container {
            display: flex;
            gap: 12px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        .tab-button {
            padding: 10px 20px;
            font-size: 0.85rem;
            border-radius: 25px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        
        .tab-button.active {
            background: linear-gradient(135deg, var(--duke-blue), var(--duke-navy));
            color: white;
            box-shadow: 0 4px 15px rgba(37, 99, 235, 0.3);
        }
        
        .tab-button:not(.active) {
            background: var(--duke-light-gray);
            color: var(--duke-gray);
        }
        
        .tab-button:not(.active):hover {
            background: linear-gradient(135deg, #e2e8f0, #cbd5e1);
            transform: translateY(-1px);
        }
        
        .no-data-message {
            text-align: center;
            padding: 50px;
            color: var(--duke-gray);
            font-style: italic;
            background: rgba(107, 114, 128, 0.05);
            border-radius: 16px;
            margin: 20px 0;
        }
        
        .subscriber-note {
            background: linear-gradient(135deg, #fef3cd, #fef3cd);
            padding: 20px;
            border-radius: 20px;
            margin-top: 20px;
            border-left: 4px solid var(--duke-orange);
            box-shadow: 0 4px 15px rgba(234, 88, 12, 0.1);
            font-size: 0.9rem;
            color: var(--duke-gray);
        }
        
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
                gap: 20px;
            }
            
            .metric-grid {
                grid-template-columns: 1fr 1fr;
            }
            
            .header h1 {
                font-size: 2.5rem;
            }
            
            .header .subtitle {
                font-size: 1.1rem;
            }
            
            .container {
                padding: 15px;
            }
        }
        
        @media (max-width: 480px) {
            .metric-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .data-overview-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Duke Chapel Analytics</h1>
            <p class="subtitle">Marketing Performance Dashboard</p>
            <p class="tagline">Comprehensive insights across digital platforms</p>
        </div>
        
        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <h3>üìä Upload Your Marketing Data Files</h3>
                <p style="margin: 20px 0; color: var(--duke-gray); font-size: 1.1rem;">Drag and drop CSV files here or click to select</p>
                <input type="file" id="fileInput" class="file-input" multiple accept=".csv">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    üì§ Choose Files
                </button>
                <div class="file-list" id="fileList"></div>
            </div>
        </div>
        
        <div class="controls" id="controls" style="display: none;">
            <div class="control-group">
                <label>üìÖ Start Date</label>
                <input type="date" id="startDate">
            </div>
            <div class="control-group">
                <label>üìÖ End Date</label>
                <input type="date" id="endDate">
            </div>
            <div class="control-group">
                <label>‚ö° Quick Select</label>
                <button class="upload-btn" onclick="selectFullRange()" style="padding: 12px 24px; font-size: 0.9rem;">Full Range</button>
            </div>
            <div class="control-group">
                <label>üìä Compare With</label>
                <select id="compareType">
                    <option value="none">No Comparison</option>
                    <option value="previous">Previous Period</option>
                    <option value="year">Same Period Last Year</option>
                </select>
            </div>
            <button class="upload-btn" onclick="updateDashboard()">üîÑ Update Dashboard</button>
            <div id="dateRangeInfo"></div>
        </div>
        
        <div id="dashboard"></div>
    </div>

    <script>
        let uploadedFiles = {};
        let processedData = {};
        
        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        
        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });
        
        function handleFiles(files) {
            Array.from(files).forEach(file => {
                if (file.type === 'text/csv' || file.name.endsWith('.csv')) {
                    uploadedFiles[file.name] = file;
                    displayFile(file.name);
                    processFile(file);
                }
            });
            
            if (Object.keys(uploadedFiles).length > 0) {
                document.getElementById('controls').style.display = 'flex';
                setDefaultDates();
                setupDateValidation();
            }
        }
        
        function setupDateValidation() {
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            const compareTypeSelect = document.getElementById('compareType');
            
            startDateInput.addEventListener('change', () => {
                if (startDateInput.value && endDateInput.value) {
                    if (new Date(startDateInput.value) > new Date(endDateInput.value)) {
                        endDateInput.value = startDateInput.value;
                    }
                    updateDashboard();
                }
            });
            
            endDateInput.addEventListener('change', () => {
                if (startDateInput.value && endDateInput.value) {
                    if (new Date(endDateInput.value) < new Date(startDateInput.value)) {
                        startDateInput.value = endDateInput.value;
                    }
                    updateDashboard();
                }
            });
            
            compareTypeSelect.addEventListener('change', () => {
                if (startDateInput.value && endDateInput.value) {
                    updateDashboard();
                }
            });
        }
        
        function displayFile(fileName) {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            fileItem.textContent = fileName;
            fileList.appendChild(fileItem);
        }
        
        // Enhanced parsing functions for numeric values
        function parsePercentage(str) {
            if (str === null || str === undefined || str === '') return 0;
            if (typeof str === 'number') return isNaN(str) ? 0 : str;
            if (typeof str === 'string') {
                const cleaned = str.replace(/[%,\s]/g, '');
                if (cleaned === '') return 0;
                const parsed = parseFloat(cleaned);
                return isNaN(parsed) ? 0 : parsed;
            }
            return 0;
        }
        
        function parseNumber(str) {
            if (str === null || str === undefined || str === '') return 0;
            if (typeof str === 'number') return isNaN(str) ? 0 : str;
            if (typeof str === 'string') {
                const cleaned = str.replace(/[,\s]/g, '');
                if (cleaned === '') return 0;
                const parsed = parseFloat(cleaned);
                return isNaN(parsed) ? 0 : parsed;
            }
            return 0;
        }
        
        function parseDate(dateStr) {
            if (typeof dateStr === 'number' && dateStr.toString().length === 10) {
                const str = dateStr.toString();
                const year = str.substring(0, 4);
                const month = str.substring(4, 6);
                const day = str.substring(6, 8);
                const hour = str.substring(8, 10);
                return new Date(year, month - 1, day, hour);
            } else if (typeof dateStr === 'string') {
                return new Date(dateStr);
            }
            return new Date(dateStr);
        }
        
        function processFile(file) {
            // Special handling for UTF-16 encoded audience files
            if (file.name === 'IG_Audience.csv' || file.name === 'FB_Audience.csv') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const arrayBuffer = e.target.result;
                    const decoder = new TextDecoder('utf-16le');
                    const content = decoder.decode(arrayBuffer);
                    processedData[file.name] = content;
                    checkAllFilesProcessed();
                };
                reader.readAsArrayBuffer(file);
            } else {
                // Regular CSV processing for other files
                Papa.parse(file, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    delimitersToGuess: [',', '\t', '|', ';'],
                    complete: (results) => {
                        // Clean column headers by trimming whitespace
                        if (results.data.length > 0) {
                            const cleanedData = results.data.map(row => {
                                const cleanedRow = {};
                                Object.keys(row).forEach(key => {
                                    const cleanKey = key.trim();
                                    cleanedRow[cleanKey] = row[key];
                                });
                                return cleanedRow;
                            });
                            processedData[file.name] = cleanedData;
                        } else {
                            processedData[file.name] = results.data;
                        }
                        checkAllFilesProcessed();
                    },
                    error: (error) => {
                        console.log(`Error parsing ${file.name}:`, error);
                        processedData[file.name] = [];
                        checkAllFilesProcessed();
                    }
                });
            }
        }
        
        function checkAllFilesProcessed() {
            if (Object.keys(processedData).length === Object.keys(uploadedFiles).length) {
                generateDashboard();
            }
        }
        
        function setDefaultDates() {
            const dateRange = getDataDateRange();
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            
            if (dateRange.min && dateRange.max) {
                startDateInput.min = dateRange.min.toISOString().split('T')[0];
                startDateInput.max = dateRange.max.toISOString().split('T')[0];
                endDateInput.min = dateRange.min.toISOString().split('T')[0];
                endDateInput.max = dateRange.max.toISOString().split('T')[0];
                
                const minDateStr = dateRange.min.toLocaleDateString();
                const maxDateStr = dateRange.max.toLocaleDateString();
                dateRangeInfo.innerHTML = `üìÖ Data available from ${minDateStr} to ${maxDateStr}`;
                
                const daysDiff = (dateRange.max - dateRange.min) / (1000 * 60 * 60 * 24);
                if (daysDiff <= 30) {
                    startDateInput.value = dateRange.min.toISOString().split('T')[0];
                    endDateInput.value = dateRange.max.toISOString().split('T')[0];
                } else {
                    const thirtyDaysAgo = new Date(dateRange.max.getTime() - (30 * 24 * 60 * 60 * 1000));
                    startDateInput.value = Math.max(thirtyDaysAgo, dateRange.min).toISOString().split('T')[0];
                    endDateInput.value = dateRange.max.toISOString().split('T')[0];
                }
            } else {
                const today = new Date();
                const thirtyDaysAgo = new Date(today.getTime() - (30 * 24 * 60 * 60 * 1000));
                
                endDateInput.value = today.toISOString().split('T')[0];
                startDateInput.value = thirtyDaysAgo.toISOString().split('T')[0];
                dateRangeInfo.innerHTML = `‚ö†Ô∏è No date data found in files - using current date`;
            }
        }
        
        function getDataDateRange() {
            let minDate = null;
            let maxDate = null;
            
            // Check all date fields across files
            const dateFields = {
                'GA_Demographics.csv': 'Date + hour (YYYYMMDDHH)',
                'GA_Traffic_Acquisition.csv': 'Date + hour (YYYYMMDDHH)',
                'GA_Pages_And_Screens.csv': 'Date + hour (YYYYMMDDHH)',
                'GA_UTMs.csv': 'Date + hour (YYYYMMDDHH)',
                'FB_Interactions.csv': 'Date',
                'FB_Reach.csv': 'Date',
                'FB_Follows.csv': 'Date',
                'FB_Link_clicks.csv': 'Date',
                'FB_Views.csv': 'Date',
                'FB_Visits.csv': 'Date',
                'FB_Videos.csv': 'Date',
                'FB_Posts.csv': 'Publish time',
                'IG_Interactions.csv': 'Date',
                'IG_Reach.csv': 'Date',
                'IG_Follows.csv': 'Date',
                'IG_Link_clicks.csv': 'Date',
                'IG_Views.csv': 'Date',
                'IG_Visits.csv': 'Date',
                'IG_Posts.csv': 'Publish time',
                'YouTube_Content.csv': 'Video publish time'
            };
            
            Object.entries(dateFields).forEach(([fileName, dateField]) => {
                if (processedData[fileName] && Array.isArray(processedData[fileName])) {
                    processedData[fileName].forEach(row => {
                        if (row[dateField]) {
                            const date = parseDate(row[dateField]);
                            if (!isNaN(date.getTime())) {
                                if (!minDate || date < minDate) minDate = date;
                                if (!maxDate || date > maxDate) maxDate = date;
                            }
                        }
                    });
                }
            });
            
            return { min: minDate, max: maxDate };
        }
        
        function selectFullRange() {
            const dateRange = getDataDateRange();
            if (dateRange.min && dateRange.max) {
                document.getElementById('startDate').value = dateRange.min.toISOString().split('T')[0];
                document.getElementById('endDate').value = dateRange.max.toISOString().split('T')[0];
                updateDashboard();
            }
        }
        
        function filterDataByDate(data, dateField, startDate, endDate) {
            if (!startDate || !endDate) return data;
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            return data.filter(row => {
                const date = parseDate(row[dateField]);
                return date >= start && date <= end;
            });
        }
        
        function generateDashboard(startDate = null, endDate = null, compareType = 'none') {
            const dashboard = document.getElementById('dashboard');
            dashboard.innerHTML = '';
            
            // Add data overview section
            const dataOverview = createDataOverview(startDate, endDate);
            dashboard.appendChild(dataOverview);
            
            // Web Analytics Section
            if (processedData['GA_Demographics.csv'] || processedData['GA_Traffic_Acquisition.csv']) {
                dashboard.appendChild(createSectionHeader('üåê Web Analytics'));
                generateWebAnalytics(dashboard, startDate, endDate, compareType);
            }
            
            // Social Media Section
            if (processedData['FB_Interactions.csv'] || processedData['IG_Posts.csv'] || processedData['FB_Videos.csv'] || 
                processedData['FB_Audience.csv'] || processedData['IG_Audience.csv']) {
                dashboard.appendChild(createSectionHeader('üì± Social Media Analytics'));
                generateSocialAnalytics(dashboard, startDate, endDate, compareType);
            }
            
            // Email Section
            if (processedData['Email_Campaign_Performance.csv']) {
                dashboard.appendChild(createSectionHeader('üìß Email Marketing Analytics'));
                generateEmailAnalytics(dashboard, startDate, endDate, compareType);
            }
            
            // YouTube Section
            if (processedData['YouTube_Content.csv']) {
                dashboard.appendChild(createSectionHeader('üé• YouTube Analytics'));
                generateYouTubeAnalytics(dashboard, startDate, endDate, compareType);
            }
        }
        
        function createDataOverview(startDate, endDate) {
            const overviewCard = createCard('üìã Data Overview & Status');
            
            const dataTypes = {
                'Web Analytics': ['GA_Demographics.csv', 'GA_Traffic_Acquisition.csv', 'GA_Pages_And_Screens.csv', 'GA_UTMs.csv'],
                'Facebook': ['FB_Interactions.csv', 'FB_Reach.csv', 'FB_Follows.csv', 'FB_Videos.csv', 'FB_Posts.csv', 'FB_Audience.csv'],
                'Instagram': ['IG_Posts.csv', 'IG_Interactions.csv', 'IG_Reach.csv', 'IG_Follows.csv', 'IG_Audience.csv'],
                'Email': ['Email_Campaign_Performance.csv'],
                'YouTube': ['YouTube_Content.csv', 'YouTube_Age.csv', 'YouTube_Gender.csv', 'YouTube_Geography.csv', 'YouTube_Subscription_Status.csv']
            };
            
            let overviewHTML = `<div class="data-overview-grid">`;
            
            Object.entries(dataTypes).forEach(([category, files]) => {
                const loadedFiles = files.filter(file => processedData[file]);
                const totalFiles = files.length;
                const loadedCount = loadedFiles.length;
                
                let statusColor = loadedCount === 0 ? '#dc2626' : loadedCount === totalFiles ? 'var(--duke-green)' : 'var(--duke-orange)';
                let statusIcon = loadedCount === 0 ? '‚ùå' : loadedCount === totalFiles ? '‚úÖ' : '‚ö†Ô∏è';
                
                overviewHTML += `
                    <div class="data-status-card" style="border-left-color: ${statusColor};">
                        <h4>${statusIcon} ${category}</h4>
                        <p>${loadedCount}/${totalFiles} files loaded</p>
                        ${loadedFiles.length > 0 ? `<small>Loaded: ${loadedFiles.join(', ')}</small>` : ''}
                    </div>
                `;
            });
            
            overviewHTML += '</div>';
            
            // Add audience analytics info
            const audienceFiles = ['FB_Audience.csv', 'IG_Audience.csv'].filter(file => processedData[file]);
            if (audienceFiles.length > 0) {
                overviewHTML += `
                    <div style="background: linear-gradient(135deg, #f0fdf4, #dcfce7); padding: 20px; border-radius: 20px; margin-top: 20px; border-left: 4px solid var(--duke-green); box-shadow: 0 4px 15px rgba(5, 150, 105, 0.1);">
                        <h4 style="margin: 0 0 10px 0; color: var(--duke-navy); font-family: 'Montserrat', sans-serif; font-weight: 700;">üë• Audience Demographics Available</h4>
                        <p style="margin: 0; font-size: 0.9rem; color: var(--duke-gray); font-family: 'Montserrat', sans-serif;">
                            Loaded: <strong>${audienceFiles.join(', ')}</strong><br>
                            <small>Age, gender, and location demographics are displayed in the Social Media section</small>
                        </p>
                    </div>
                `;
            }
            
            if (startDate && endDate) {
                overviewHTML += `
                    <div style="background: linear-gradient(135deg, #fef3cd, #fef3cd); padding: 20px; border-radius: 20px; margin-top: 20px; border-left: 4px solid var(--duke-orange); box-shadow: 0 4px 15px rgba(234, 88, 12, 0.1);">
                        <h4 style="margin: 0 0 10px 0; color: var(--duke-navy); font-family: 'Montserrat', sans-serif; font-weight: 700;">üìÖ Date Range Filter Active</h4>
                        <p style="margin: 0; font-size: 0.9rem; color: var(--duke-gray); font-family: 'Montserrat', sans-serif;">
                            Showing data from <strong>${new Date(startDate).toLocaleDateString()}</strong> to <strong>${new Date(endDate).toLocaleDateString()}</strong>
                        </p>
                    </div>
                `;
            }
            
            overviewCard.innerHTML += overviewHTML;
            return overviewCard;
        }
        
        function createSectionHeader(title) {
            const header = document.createElement('div');
            header.className = 'section-header';
            header.textContent = title;
            return header;
        }
        
        function generateWebAnalytics(dashboard, startDate = null, endDate = null, compareType = 'none') {
            const container = document.createElement('div');
            container.className = 'dashboard';
            
            // Demographics Card
            if (processedData['GA_Demographics.csv']) {
                let demographics = processedData['GA_Demographics.csv'];
                
                if (startDate && endDate) {
                    demographics = filterDataByDate(demographics, 'Date + hour (YYYYMMDDHH)', startDate, endDate);
                }
                
                const card = createCard('üåç Demographics & User Insights');
                
                // Metrics
                const totalUsers = demographics.reduce((sum, row) => sum + parseNumber(row['Total users']), 0);
                const newUsers = demographics.reduce((sum, row) => sum + parseNumber(row['New users']), 0);
                const returningUsers = demographics.reduce((sum, row) => sum + parseNumber(row['Returning users']), 0);
                const totalSessions = demographics.reduce((sum, row) => sum + parseNumber(row.Sessions), 0);
                const avgEngagement = demographics.length > 0 ? 
                    demographics.reduce((sum, row) => sum + parseNumber(row['Engagement rate']), 0) / demographics.length : 0;
                const avgEngagementTime = demographics.length > 0 ? 
                    demographics.reduce((sum, row) => sum + parseNumber(row['Average engagement time per session']), 0) / demographics.length : 0;
                
                const metricsGrid = document.createElement('div');
                metricsGrid.className = 'metric-grid';
                metricsGrid.innerHTML = `
                    ${createMetric(totalUsers, 'Total Users')}
                    ${createMetric(newUsers, 'New Users')}
                    ${createMetric(Math.round((newUsers/totalUsers) * 100) + '%', 'New User %')}
                    ${createMetric(totalSessions, 'Sessions')}
                    ${createMetric((avgEngagement * 100).toFixed(1) + '%', 'Engagement Rate')}
                    ${createMetric(Math.round(avgEngagementTime) + 's', 'Avg. Session Time')}
                `;
                card.appendChild(metricsGrid);
                
                // Top countries and cities
                const locationData = demographics.reduce((acc, row) => {
                    const country = row.Country || 'Unknown';
                    const city = row.City || 'Unknown';
                    if (!acc[country]) acc[country] = { sessions: 0, cities: {} };
                    acc[country].sessions += parseNumber(row.Sessions);
                    if (!acc[country].cities[city]) acc[country].cities[city] = 0;
                    acc[country].cities[city] += parseNumber(row.Sessions);
                    return acc;
                }, {});
                
                const topCountries = Object.entries(locationData)
                    .sort(([,a], [,b]) => b.sessions - a.sessions)
                    .slice(0, 5);
                
                const tableContainer = document.createElement('div');
                tableContainer.className = 'table-container';
                tableContainer.innerHTML = `
                    <table>
                        <thead>
                            <tr><th>Country</th><th>Sessions</th><th>Top City</th><th>City Sessions</th></tr>
                        </thead>
                        <tbody>
                            ${topCountries.map(([country, data]) => {
                                const topCity = Object.entries(data.cities).sort(([,a], [,b]) => b - a)[0];
                                return `<tr>
                                    <td><strong>${country}</strong></td>
                                    <td>${data.sessions.toLocaleString()}</td>
                                    <td>${topCity ? topCity[0] : 'N/A'}</td>
                                    <td>${topCity ? topCity[1].toLocaleString() : '0'}</td>
                                </tr>`;
                            }).join('')}
                        </tbody>
                    </table>
                `;
                card.appendChild(tableContainer);
                container.appendChild(card);
            }
            
            // Traffic Sources
            if (processedData['GA_Traffic_Acquisition.csv']) {
                let traffic = processedData['GA_Traffic_Acquisition.csv'];
                
                if (startDate && endDate) {
                    traffic = filterDataByDate(traffic, 'Date + hour (YYYYMMDDHH)', startDate, endDate);
                }
                
                const card = createCard('üöÄ Traffic Sources & Channels');
                
                const channelData = traffic.reduce((acc, row) => {
                    const channel = row['Session primary channel group (Default Channel Group)'] || 'Unknown';
                    if (!acc[channel]) {
                        acc[channel] = { 
                            sessions: 0, 
                            engagedSessions: 0, 
                            keyEvents: 0,
                            avgEngagementTime: 0,
                            count: 0
                        };
                    }
                    acc[channel].sessions += parseNumber(row.Sessions);
                    acc[channel].engagedSessions += parseNumber(row['Engaged sessions']);
                    acc[channel].keyEvents += parseNumber(row['Key events']);
                    acc[channel].avgEngagementTime += parseNumber(row['Average engagement time per session']);
                    acc[channel].count++;
                    return acc;
                }, {});
                
                // Calculate averages
                Object.keys(channelData).forEach(channel => {
                    channelData[channel].avgEngagementTime = channelData[channel].avgEngagementTime / channelData[channel].count;
                    channelData[channel].engagementRate = channelData[channel].sessions > 0 ? 
                        (channelData[channel].engagedSessions / channelData[channel].sessions) * 100 : 0;
                });
                
                const chartContainer = document.createElement('div');
                chartContainer.className = 'chart-container';
                const canvas = document.createElement('canvas');
                chartContainer.appendChild(canvas);
                card.appendChild(chartContainer);
                
                setTimeout(() => {
                    new Chart(canvas, {
                        type: 'doughnut',
                        data: {
                            labels: Object.keys(channelData),
                            datasets: [{
                                data: Object.values(channelData).map(d => d.sessions),
                                backgroundColor: [
                                    '#1a365d', '#2563eb', '#ea580c', '#f59e0b',
                                    '#0891b2', '#059669', '#7c3aed', '#a3a3a3',
                                    '#6b7280', '#f3f4f6'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        padding: 20,
                                        usePointStyle: true,
                                        font: {
                                            family: 'Montserrat'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }, 100);
                
                container.appendChild(card);
            }
            
            // Top Landing Pages
            if (processedData['GA_Pages_And_Screens.csv']) {
                let pages = processedData['GA_Pages_And_Screens.csv'];
                
                if (startDate && endDate) {
                    pages = filterDataByDate(pages, 'Date + hour (YYYYMMDDHH)', startDate, endDate);
                }
                
                const card = createCard('üìÑ Top Landing Pages by Sessions & Engagement');
                
                const pageData = pages.reduce((acc, row) => {
                    const path = row['Page path and screen class'] || 'Unknown';
                    const title = row['Page title and screen class'] || 'Unknown';
                    if (!acc[path]) {
                        acc[path] = { 
                            views: 0, 
                            users: 0, 
                            keyEvents: 0, 
                            title: title,
                            eventCount: 0,
                            totalEngagementTime: 0,
                            sessions: 0
                        };
                    }
                    acc[path].views += parseNumber(row.Views);
                    acc[path].users += parseNumber(row['Active users']);
                    acc[path].keyEvents += parseNumber(row['Key events']);
                    acc[path].eventCount += parseNumber(row['Event count']);
                    
                    // Estimate engagement time based on active users and average engagement
                    const userEngagementTime = parseNumber(row['Active users']) * 45; // Estimated 45s per user
                    acc[path].totalEngagementTime += userEngagementTime;
                    acc[path].sessions += parseNumber(row['Active users']); // Use active users as proxy for sessions
                    return acc;
                }, {});
                
                // Calculate average engagement time per page
                Object.keys(pageData).forEach(page => {
                    pageData[page].avgEngagementTime = pageData[page].sessions > 0 ? 
                        pageData[page].totalEngagementTime / pageData[page].sessions : 0;
                });
                
                const topPagesByEngagement = Object.entries(pageData)
                    .sort(([,a], [,b]) => b.totalEngagementTime - a.totalEngagementTime)
                    .slice(0, 10);
                
                const tableContainer = document.createElement('div');
                tableContainer.className = 'table-container';
                tableContainer.innerHTML = `
                    <table>
                        <thead>
                            <tr>
                                <th>Page Path</th>
                                <th>Views</th>
                                <th>Users</th>
                                <th>Est. Total Engagement Time</th>
                                <th>Key Events</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${topPagesByEngagement.map(([page, data]) => 
                                `<tr>
                                    <td><strong>${page}</strong></td>
                                    <td>${data.views.toLocaleString()}</td>
                                    <td>${data.users.toLocaleString()}</td>
                                    <td>${Math.round(data.totalEngagementTime / 60).toLocaleString()} min</td>
                                    <td>${data.keyEvents.toLocaleString()}</td>
                                </tr>`
                            ).join('')}
                        </tbody>
                    </table>
                `;
                card.appendChild(tableContainer);
                container.appendChild(card);
            }
            
            // Campaign Performance (UTM tracking)
            if (processedData['GA_UTMs.csv']) {
                let utms = processedData['GA_UTMs.csv'];
                
                if (startDate && endDate) {
                    utms = filterDataByDate(utms, 'Date + hour (YYYYMMDDHH)', startDate, endDate);
                }
                
                const card = createCard('üéØ Campaign Performance (Specific Campaigns)');
                
                const campaignData = utms.reduce((acc, row) => {
                    const campaign = row['Manual campaign name'] || 'Unknown';
                    const source = row['Manual source / medium'] || 'Unknown';
                    const key = `${campaign} (${source})`;
                    
                    if (!acc[key]) {
                        acc[key] = { 
                            sessions: 0, 
                            engagedSessions: 0, 
                            keyEvents: 0, 
                            eventValue: 0 
                        };
                    }
                    acc[key].sessions += parseNumber(row.Sessions);
                    acc[key].engagedSessions += parseNumber(row['Engaged sessions']);
                    acc[key].keyEvents += parseNumber(row['Key events']);
                    acc[key].eventValue += parseNumber(row['Event value']);
                    return acc;
                }, {});
                
                const topCampaigns = Object.entries(campaignData)
                    .sort(([,a], [,b]) => b.sessions - a.sessions)
                    .slice(0, 8);
                
                if (topCampaigns.length > 0) {
                    const tableContainer = document.createElement('div');
                    tableContainer.className = 'table-container';
                    tableContainer.innerHTML = `
                        <table>
                            <thead>
                                <tr>
                                    <th>Campaign (Source)</th>
                                    <th>Sessions</th>
                                    <th>Engaged</th>
                                    <th>Events</th>
                                    <th>Event Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${topCampaigns.map(([campaign, data]) => 
                                    `<tr>
                                        <td><strong>${campaign}</strong></td>
                                        <td>${data.sessions.toLocaleString()}</td>
                                        <td>${data.engagedSessions.toLocaleString()}</td>
                                        <td>${data.keyEvents.toLocaleString()}</td>
                                        <td>$${data.eventValue.toLocaleString()}</td>
                                    </tr>`
                                ).join('')}
                            </tbody>
                        </table>
                    `;
                    card.appendChild(tableContainer);
                } else {
                    card.innerHTML += '<p class="no-data-message">No UTM campaign data available for selected period.</p>';
                }
                container.appendChild(card);
            }
            
            dashboard.appendChild(container);
        }
        
        function generateSocialAnalytics(dashboard, startDate = null, endDate = null, compareType = 'none') {
            const container = document.createElement('div');
            container.className = 'dashboard';
            
            // Social Media Audience Demographics
            generateAudienceDemographics(container);
            
            // Page Rank Note
            const pageRankCard = createCard('üìä Page Rank Information');
            pageRankCard.innerHTML += `
                <div class="subscriber-note">
                    <strong>üìà Page Rank Data:</strong> Page rank information is not included in the standard Facebook export files. 
                    This metric would need to be obtained through Facebook Insights' Page Quality tab or through the Facebook Graph API.
                    <br><br>
                    <strong>Alternative Metrics Available:</strong> We're showing reach, engagement, and follower growth trends which are good indicators of page performance.
                </div>
            `;
            container.appendChild(pageRankCard);
            
            // Facebook Analytics Overview
            if (processedData['FB_Interactions.csv'] || processedData['FB_Reach.csv']) {
                const card = createCard('üìò Facebook Performance - General Metrics');
                const metricsGrid = document.createElement('div');
                metricsGrid.className = 'metric-grid';
                
                let fbReach = 0, fbInteractions = 0, fbFollows = 0, fbViews = 0, fbVisits = 0, fbLinkClicks = 0;
                
                // Calculate Facebook metrics with proper number parsing
                if (processedData['FB_Reach.csv']) {
                    let reachData = processedData['FB_Reach.csv'];
                    if (startDate && endDate) {
                        reachData = filterDataByDate(reachData, 'Date', startDate, endDate);
                    }
                    fbReach = reachData.reduce((sum, row) => sum + parseNumber(row.Primary), 0);
                }
                
                if (processedData['FB_Interactions.csv']) {
                    let interactionData = processedData['FB_Interactions.csv'];
                    if (startDate && endDate) {
                        interactionData = filterDataByDate(interactionData, 'Date', startDate, endDate);
                    }
                    fbInteractions = interactionData.reduce((sum, row) => sum + parseNumber(row.Primary), 0);
                }
                
                if (processedData['FB_Follows.csv']) {
                    let followData = processedData['FB_Follows.csv'];
                    if (startDate && endDate) {
                        followData = filterDataByDate(followData, 'Date', startDate, endDate);
                    }
                    fbFollows = followData.reduce((sum, row) => sum + parseNumber(row.Primary), 0);
                }
                
                if (processedData['FB_Views.csv']) {
                    let viewData = processedData['FB_Views.csv'];
                    if (startDate && endDate) {
                        viewData = filterDataByDate(viewData, 'Date', startDate, endDate);
                    }
                    fbViews = viewData.reduce((sum, row) => sum + parseNumber(row.Primary), 0);
                }
                
                if (processedData['FB_Visits.csv']) {
                    let visitData = processedData['FB_Visits.csv'];
                    if (startDate && endDate) {
                        visitData = filterDataByDate(visitData, 'Date', startDate, endDate);
                    }
                    fbVisits = visitData.reduce((sum, row) => sum + parseNumber(row.Primary), 0);
                }
                
                if (processedData['FB_Link_clicks.csv']) {
                    let linkData = processedData['FB_Link_clicks.csv'];
                    if (startDate && endDate) {
                        linkData = filterDataByDate(linkData, 'Date', startDate, endDate);
                    }
                    fbLinkClicks = linkData.reduce((sum, row) => sum + parseNumber(row.Primary), 0);
                }
                
                metricsGrid.innerHTML = `
                    ${createMetric(fbReach, 'Total Reach')}
                    ${createMetric(fbInteractions, 'Interactions')}
                    ${createMetric(fbFollows, 'New Follows')}
                    ${createMetric(fbViews, 'Profile Views')}
                    ${createMetric(fbVisits, 'Page Visits')}
                    ${createMetric(fbLinkClicks, 'Link Clicks')}
                `;
                
                card.appendChild(metricsGrid);
                container.appendChild(card);
            }
            
            // Instagram Analytics Overview  
            if (processedData['IG_Interactions.csv'] || processedData['IG_Reach.csv']) {
                const card = createCard('üì∑ Instagram Performance - General Metrics');
                const metricsGrid = document.createElement('div');
                metricsGrid.className = 'metric-grid';
                
                let igReach = 0, igInteractions = 0, igFollows = 0, igViews = 0, igVisits = 0, igLinkClicks = 0;
                
                if (processedData['IG_Reach.csv']) {
                    let reachData = processedData['IG_Reach.csv'];
                    if (startDate && endDate) {
                        reachData = filterDataByDate(reachData, 'Date', startDate, endDate);
                    }
                    igReach = reachData.reduce((sum, row) => sum + parseNumber(row.Primary), 0);
                }
                
                if (processedData['IG_Interactions.csv']) {
                    let interactionData = processedData['IG_Interactions.csv'];
                    if (startDate && endDate) {
                        interactionData = filterDataByDate(interactionData, 'Date', startDate, endDate);
                    }
                    igInteractions = interactionData.reduce((sum, row) => sum + parseNumber(row.Primary), 0);
                }
                
                if (processedData['IG_Follows.csv']) {
                    let followData = processedData['IG_Follows.csv'];
                    if (startDate && endDate) {
                        followData = filterDataByDate(followData, 'Date', startDate, endDate);
                    }
                    igFollows = followData.reduce((sum, row) => sum + parseNumber(row.Primary), 0);
                }
                
                if (processedData['IG_Views.csv']) {
                    let viewData = processedData['IG_Views.csv'];
                    if (startDate && endDate) {
                        viewData = filterDataByDate(viewData, 'Date', startDate, endDate);
                    }
                    igViews = viewData.reduce((sum, row) => sum + parseNumber(row.Primary), 0);
                }
                
                if (processedData['IG_Visits.csv']) {
                    let visitData = processedData['IG_Visits.csv'];
                    if (startDate && endDate) {
                        visitData = filterDataByDate(visitData, 'Date', startDate, endDate);
                    }
                    igVisits = visitData.reduce((sum, row) => sum + parseNumber(row.Primary), 0);
                }
                
                if (processedData['IG_Link_clicks.csv']) {
                    let linkData = processedData['IG_Link_clicks.csv'];
                    if (startDate && endDate) {
                        linkData = filterDataByDate(linkData, 'Date', startDate, endDate);
                    }
                    igLinkClicks = linkData.reduce((sum, row) => sum + parseNumber(row.Primary), 0);
                }
                
                metricsGrid.innerHTML = `
                    ${createMetric(igReach, 'Total Reach')}
                    ${createMetric(igInteractions, 'Interactions')}
                    ${createMetric(igFollows, 'New Follows')}
                    ${createMetric(igViews, 'Profile Views')}
                    ${createMetric(igVisits, 'Page Visits')}
                    ${createMetric(igLinkClicks, 'Link Clicks')}
                `;
                
                card.appendChild(metricsGrid);
                container.appendChild(card);
            }
            
            // Top Instagram Posts Analysis
            if (processedData['IG_Posts.csv'] && processedData['IG_Posts.csv'].length > 0) {
                let posts = processedData['IG_Posts.csv'];
                
                if (startDate && endDate) {
                    const start = new Date(startDate);
                    const end = new Date(endDate);
                    posts = posts.filter(post => {
                        if (post['Publish time']) {
                            const postDate = new Date(post['Publish time']);
                            return postDate >= start && postDate <= end;
                        } else if (post['Date']) {
                            const postDate = new Date(post['Date']);
                            return postDate >= start && postDate <= end;
                        }
                        return true;
                    });
                }
                
                const card = createCard('üèÜ Top 5 Instagram Posts');
                
                // Create tabs for different sorting options
                const tabContainer = document.createElement('div');
                tabContainer.className = 'tab-container';
                
                ['Reach', 'Likes', 'Comments', 'Saves', 'Shares'].forEach((metric, index) => {
                    const tab = document.createElement('button');
                    tab.className = 'tab-button';
                    if (index === 0) tab.classList.add('active');
                    tab.textContent = `By ${metric}`;
                    tab.onclick = () => displayTopPosts(metric, posts, card);
                    tabContainer.appendChild(tab);
                });
                
                card.appendChild(tabContainer);
                
                // Initial display
                displayTopPosts('Reach', posts, card);
                container.appendChild(card);
            }
            
            // Top Facebook Posts Analysis (if available)
            if (processedData['FB_Posts.csv'] && processedData['FB_Posts.csv'].length > 0) {
                let fbPosts = processedData['FB_Posts.csv'];
                
                if (startDate && endDate) {
                    const start = new Date(startDate);
                    const end = new Date(endDate);
                    fbPosts = fbPosts.filter(post => {
                        if (post['Publish time']) {
                            const postDate = new Date(post['Publish time']);
                            return postDate >= start && postDate <= end;
                        } else if (post['Date']) {
                            const postDate = new Date(post['Date']);
                            return postDate >= start && postDate <= end;
                        }
                        return true;
                    });
                }
                
                const fbCard = createCard('üìò Top 5 Facebook Posts');
                
                // Create tabs for Facebook posts
                const fbTabContainer = document.createElement('div');
                fbTabContainer.className = 'tab-container';
                
                ['Reach', 'Reactions', 'Comments', 'Shares', 'Total clicks'].forEach((metric, index) => {
                    const tab = document.createElement('button');
                    tab.className = 'tab-button';
                    if (index === 0) tab.classList.add('active');
                    tab.textContent = `By ${metric.includes('Total clicks') ? 'Clicks' : metric}`;
                    tab.onclick = () => displayTopFacebookPosts(metric, fbPosts, fbCard);
                    fbTabContainer.appendChild(tab);
                });
                
                fbCard.appendChild(fbTabContainer);
                
                // Initial display
                displayTopFacebookPosts('Reach', fbPosts, fbCard);
                container.appendChild(fbCard);
            }
            
            // Facebook Videos Performance
            if (processedData['FB_Videos.csv'] && processedData['FB_Videos.csv'].length > 0) {
                let videos = processedData['FB_Videos.csv'];
                
                if (startDate && endDate) {
                    const start = new Date(startDate);
                    const end = new Date(endDate);
                    videos = videos.filter(video => {
                        if (video.Date) {
                            const videoDate = new Date(video.Date);
                            return videoDate >= start && videoDate <= end;
                        }
                        return true;
                    });
                }
                
                if (videos.length > 0) {
                    const card = createCard('üé¨ Facebook Video Performance');
                    
                    const topVideos = videos
                        .filter(video => parseNumber(video.Reach) > 0)
                        .sort((a, b) => parseNumber(b.Reach) - parseNumber(a.Reach))
                        .slice(0, 5);
                    
                    if (topVideos.length > 0) {
                        const tableContainer = document.createElement('div');
                        tableContainer.className = 'table-container';
                        tableContainer.innerHTML = `
                            <table>
                                <thead>
                                    <tr>
                                        <th>Video Title</th>
                                        <th>Reach</th>
                                        <th>3s Views</th>
                                        <th>1m Views</th>
                                        <th>Engagement</th>
                                        <th>Watch Time (hrs)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${topVideos.map(video => 
                                        `<tr>
                                            <td><strong>${(video.Title || 'Untitled').substring(0, 40)}...</strong></td>
                                            <td>${parseNumber(video.Reach).toLocaleString()}</td>
                                            <td>${parseNumber(video['3-second video views']).toLocaleString()}</td>
                                            <td>${parseNumber(video['1-minute video views']).toLocaleString()}</td>
                                            <td>${parseNumber(video['Reactions, Comments and Shares']).toLocaleString()}</td>
                                            <td>${(parseNumber(video['Seconds viewed']) / 3600).toFixed(1)}</td>
                                        </tr>`
                                    ).join('')}
                                </tbody>
                            </table>
                        `;
                        card.appendChild(tableContainer);
                    } else {
                        card.innerHTML += '<p class="no-data-message">No video data available for selected period.</p>';
                    }
                    container.appendChild(card);
                }
            }
            
            dashboard.appendChild(container);
        }
        
        function generateAudienceDemographics(container) {
            // Facebook Audience Demographics
            if (processedData['FB_Audience.csv']) {
                const fbCard = createCard('üìä Facebook Audience Demographics');
                processFacebookAudience(fbCard, processedData['FB_Audience.csv']);
                container.appendChild(fbCard);
            }
            
            // Instagram Audience Demographics  
            if (processedData['IG_Audience.csv']) {
                const igCard = createCard('üì∑ Instagram Audience Demographics');
                processInstagramAudience(igCard, processedData['IG_Audience.csv']);
                container.appendChild(igCard);
            }
        }
        
        function processFacebookAudience(card, rawData) {
            // Facebook audience data has a specific structure - parse it properly
            const lines = rawData.split('\n').map(line => line.trim()).filter(line => line);
            
            // Find sections
            let ageData = [];
            let cityData = [];
            let countryData = [];
            let currentSection = '';
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                if (line.includes('Age & gender')) {
                    currentSection = 'age';
                    i++; // Skip header
                    continue;
                } else if (line.includes('Top cities')) {
                    currentSection = 'cities';
                    i++; // Skip header
                    continue;
                } else if (line.includes('Top countries')) {
                    currentSection = 'countries';
                    i++; // Skip header
                    continue;
                }
                
                if (currentSection === 'age' && line.includes(',')) {
                    const parts = line.split(',');
                    if (parts.length >= 3 && (parts[0].includes('-') || parts[0].includes('+'))) {
                        ageData.push({
                            age: parts[0].replace(/"/g, '').trim(),
                            women: parseFloat(parts[1].replace(/["%]/g, '').trim()) || 0,
                            men: parseFloat(parts[2].replace(/["%]/g, '').trim()) || 0
                        });
                    }
                } else if (currentSection === 'cities' && line.includes(',')) {
                    const parts = line.split(',');
                    if (parts.length === 2) {
                        cityData.push({
                            city: parts[0].replace(/"/g, '').trim(),
                            percentage: parseFloat(parts[1].replace(/["%]/g, '').trim()) || 0
                        });
                    }
                } else if (currentSection === 'countries' && line.includes(',')) {
                    const parts = line.split(',');
                    if (parts.length === 2) {
                        countryData.push({
                            country: parts[0].replace(/"/g, '').trim(),
                            percentage: parseFloat(parts[1].replace(/["%]/g, '').trim()) || 0
                        });
                    }
                }
            }
            
            // Display age demographics chart
            if (ageData.length > 0) {
                const chartContainer = document.createElement('div');
                chartContainer.className = 'chart-container';
                chartContainer.style.height = '300px';
                const canvas = document.createElement('canvas');
                chartContainer.appendChild(canvas);
                card.appendChild(chartContainer);
                
                setTimeout(() => {
                    new Chart(canvas, {
                        type: 'bar',
                        data: {
                            labels: ageData.map(d => d.age),
                            datasets: [
                                {
                                    label: 'Women (%)',
                                    data: ageData.map(d => d.women),
                                    backgroundColor: 'var(--duke-blue)',
                                    borderRadius: 4
                                },
                                {
                                    label: 'Men (%)',
                                    data: ageData.map(d => d.men),
                                    backgroundColor: 'var(--duke-orange)',
                                    borderRadius: 4
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'Facebook Audience by Age & Gender',
                                    font: { family: 'Montserrat', weight: 700, size: 16 }
                                },
                                legend: {
                                    labels: { font: { family: 'Montserrat' } }
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: { display: true, text: 'Percentage (%)', font: { family: 'Montserrat' } },
                                    ticks: { font: { family: 'Montserrat' } }
                                },
                                x: { ticks: { font: { family: 'Montserrat' } } }
                            }
                        }
                    });
                }, 100);
            }
            
            // Display top cities and countries tables
            if (cityData.length > 0 || countryData.length > 0) {
                const tablesContainer = document.createElement('div');
                tablesContainer.style.cssText = 'display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 25px;';
                
                if (cityData.length > 0) {
                    const cityTable = document.createElement('div');
                    cityTable.className = 'table-container';
                    cityTable.innerHTML = `
                        <table>
                            <thead><tr><th>Top Cities</th><th>%</th></tr></thead>
                            <tbody>
                                ${cityData.slice(0, 8).map(city => 
                                    `<tr><td><strong>${city.city}</strong></td><td>${city.percentage}%</td></tr>`
                                ).join('')}
                            </tbody>
                        </table>
                    `;
                    tablesContainer.appendChild(cityTable);
                }
                
                if (countryData.length > 0) {
                    const countryTable = document.createElement('div');
                    countryTable.className = 'table-container';
                    countryTable.innerHTML = `
                        <table>
                            <thead><tr><th>Top Countries</th><th>%</th></tr></thead>
                            <tbody>
                                ${countryData.slice(0, 8).map(country => 
                                    `<tr><td><strong>${country.country}</strong></td><td>${country.percentage}%</td></tr>`
                                ).join('')}
                            </tbody>
                        </table>
                    `;
                    tablesContainer.appendChild(countryTable);
                }
                
                card.appendChild(tablesContainer);
            }
        }
        
        function processInstagramAudience(card, data) {
            // Parse Instagram audience data
            const lines = data.split('\n').map(line => line.trim()).filter(line => line);
            
            let followerCount = 0;
            let ageData = [];
            let cityData = [];
            let countryData = [];
            let currentSection = '';
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].replace(/"/g, '');
                
                // Extract follower count
                if (line.match(/^\d+$/) && i < 5) {
                    followerCount = parseInt(line);
                }
                
                // Detect sections
                if (line.includes('by gender and age')) {
                    currentSection = 'age';
                    i++; // Skip header
                    continue;
                } else if (line.includes('by top cities')) {
                    currentSection = 'cities';
                    i++; // Skip header
                    continue;
                } else if (line.includes('by top countries')) {
                    currentSection = 'countries';
                    i++; // Skip header
                    continue;
                }
                
                // Parse data based on section
                if (currentSection === 'age' && line.includes(',')) {
                    const parts = line.split(',');
                    if (parts.length >= 3 && (parts[0].includes('-') || parts[0].includes('+'))) {
                        ageData.push({
                            age: parts[0].trim(),
                            women: parseFloat(parts[1].replace('%', '').trim()) || 0,
                            men: parseFloat(parts[2].replace('%', '').trim()) || 0
                        });
                    }
                } else if (currentSection === 'cities' && line.includes(',')) {
                    const parts = line.split(',');
                    if (parts.length >= 2) {
                        cityData.push({
                            city: parts[0].trim(),
                            percentage: parseFloat(parts[1].replace('%', '').trim()) || 0
                        });
                    }
                } else if (currentSection === 'countries' && line.includes(',')) {
                    const parts = line.split(',');
                    if (parts.length >= 2) {
                        countryData.push({
                            country: parts[0].trim(),
                            percentage: parseFloat(parts[1].replace('%', '').trim()) || 0
                        });
                    }
                }
            }
            
            // Display follower count
            if (followerCount > 0) {
                const followerMetric = document.createElement('div');
                followerMetric.className = 'metric-grid';
                followerMetric.innerHTML = `
                    <div class="metric">
                        <div class="metric-value">${followerCount.toLocaleString()}</div>
                        <div class="metric-label">Total Followers</div>
                    </div>
                `;
                card.appendChild(followerMetric);
            }
            
            // Display age demographics chart
            if (ageData.length > 0) {
                const chartContainer = document.createElement('div');
                chartContainer.className = 'chart-container';
                chartContainer.style.height = '300px';
                const canvas = document.createElement('canvas');
                chartContainer.appendChild(canvas);
                card.appendChild(chartContainer);
                
                setTimeout(() => {
                    new Chart(canvas, {
                        type: 'bar',
                        data: {
                            labels: ageData.map(d => d.age),
                            datasets: [
                                {
                                    label: 'Women (%)',
                                    data: ageData.map(d => d.women),
                                    backgroundColor: 'var(--duke-blue)',
                                    borderRadius: 4
                                },
                                {
                                    label: 'Men (%)',
                                    data: ageData.map(d => d.men),
                                    backgroundColor: 'var(--duke-orange)',
                                    borderRadius: 4
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'Instagram Audience by Age & Gender',
                                    font: { family: 'Montserrat', weight: 700, size: 16 }
                                },
                                legend: {
                                    labels: { font: { family: 'Montserrat' } }
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: { display: true, text: 'Percentage (%)', font: { family: 'Montserrat' } },
                                    ticks: { font: { family: 'Montserrat' } }
                                },
                                x: { ticks: { font: { family: 'Montserrat' } } }
                            }
                        }
                    });
                }, 100);
            }
            
            // Display top cities
            if (cityData.length > 0 || countryData.length > 0) {
                const tablesContainer = document.createElement('div');
                tablesContainer.style.cssText = 'display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 25px;';
                
                if (cityData.length > 0) {
                    const cityTable = document.createElement('div');
                    cityTable.className = 'table-container';
                    cityTable.innerHTML = `
                        <table>
                            <thead><tr><th>Top Cities</th><th>Percentage</th></tr></thead>
                            <tbody>
                                ${cityData.slice(0, 10).map(city => 
                                    `<tr><td><strong>${city.city}</strong></td><td>${city.percentage}%</td></tr>`
                                ).join('')}
                            </tbody>
                        </table>
                    `;
                    tablesContainer.appendChild(cityTable);
                }
                
                if (countryData.length > 0) {
                    const countryTable = document.createElement('div');
                    countryTable.className = 'table-container';
                    countryTable.innerHTML = `
                        <table>
                            <thead><tr><th>Top Countries</th><th>Percentage</th></tr></thead>
                            <tbody>
                                ${countryData.slice(0, 10).map(country => 
                                    `<tr><td><strong>${country.country}</strong></td><td>${country.percentage}%</td></tr>`
                                ).join('')}
                            </tbody>
                        </table>
                    `;
                    tablesContainer.appendChild(countryTable);
                }
                
                card.appendChild(tablesContainer);
            }
        }
        
        function displayTopPosts(metric, posts, card) {
            // Remove existing table if any
            const existingTable = card.querySelector('.table-container');
            if (existingTable) {
                existingTable.remove();
            }
            
            // Update tab styles
            const tabs = card.querySelectorAll('.tab-button');
            tabs.forEach((tab) => {
                tab.classList.remove('active');
                if (tab.textContent.includes(metric)) {
                    tab.classList.add('active');
                }
            });
            
            // Sort posts by selected metric
            const topPosts = posts
                .filter(post => parseNumber(post[metric] || 0) > 0 || parseNumber(post.Reach || 0) > 0)
                .sort((a, b) => parseNumber(b[metric] || 0) - parseNumber(a[metric] || 0))
                .slice(0, 5);
            
            if (topPosts.length === 0) {
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'no-data-message';
                noDataDiv.innerHTML = `üì≠ No Instagram posts found with ${metric} data for the selected time period.`;
                card.appendChild(noDataDiv);
                return;
            }
            
            const tableContainer = document.createElement('div');
            tableContainer.className = 'table-container';
            tableContainer.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Post</th>
                            <th>${metric}</th>
                            <th>Reach</th>
                            <th>Likes</th>
                            <th>Comments</th>
                            <th>Shares</th>
                            <th>Saves</th>
                            <th>Link</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${topPosts.map(post => 
                            `<tr>
                                <td><strong>${(post.Description || 'No description').substring(0, 40)}...</strong></td>
                                <td><strong style="color: var(--duke-blue);">${parseNumber(post[metric] || 0).toLocaleString()}</strong></td>
                                <td>${parseNumber(post.Reach || 0).toLocaleString()}</td>
                                <td>${parseNumber(post.Likes || 0).toLocaleString()}</td>
                                <td>${parseNumber(post.Comments || 0).toLocaleString()}</td>
                                <td>${parseNumber(post.Shares || 0).toLocaleString()}</td>
                                <td>${parseNumber(post.Saves || 0).toLocaleString()}</td>
                                <td>${post.Permalink ? `<a href="${post.Permalink}" target="_blank" style="color: var(--duke-blue); text-decoration: none; font-weight: bold;">üîó View</a>` : 'N/A'}</td>
                            </tr>`
                        ).join('')}
                    </tbody>
                </table>
            `;
            card.appendChild(tableContainer);
        }
        
        function displayTopFacebookPosts(metric, posts, card) {
            // Remove existing table if any
            const existingTable = card.querySelector('.table-container');
            if (existingTable) {
                existingTable.remove();
            }
            
            // Update tab styles
            const tabs = card.querySelectorAll('.tab-button');
            tabs.forEach((tab) => {
                tab.classList.remove('active');
                if (tab.textContent.includes(metric.includes('Total clicks') ? 'Clicks' : metric)) {
                    tab.classList.add('active');
                }
            });
            
            // Sort posts by selected metric
            const topPosts = posts
                .filter(post => parseNumber(post[metric] || 0) > 0 || parseNumber(post.Reach || 0) > 0)
                .sort((a, b) => parseNumber(b[metric] || 0) - parseNumber(a[metric] || 0))
                .slice(0, 5);
            
            if (topPosts.length === 0) {
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'no-data-message';
                noDataDiv.innerHTML = `üì≠ No Facebook posts found with ${metric} data for the selected time period.`;
                card.appendChild(noDataDiv);
                return;
            }
            
            const tableContainer = document.createElement('div');
            tableContainer.className = 'table-container';
            tableContainer.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Post</th>
                            <th>${metric.includes('Total clicks') ? 'Clicks' : metric}</th>
                            <th>Reach</th>
                            <th>Reactions</th>
                            <th>Comments</th>
                            <th>Shares</th>
                            <th>Link</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${topPosts.map(post => 
                            `<tr>
                                <td><strong>${(post.Description || post.Title || 'No description').substring(0, 40)}...</strong></td>
                                <td><strong style="color: var(--duke-blue);">${parseNumber(post[metric] || 0).toLocaleString()}</strong></td>
                                <td>${parseNumber(post.Reach || 0).toLocaleString()}</td>
                                <td>${parseNumber(post.Reactions || 0).toLocaleString()}</td>
                                <td>${parseNumber(post.Comments || 0).toLocaleString()}</td>
                                <td>${parseNumber(post.Shares || 0).toLocaleString()}</td>
                                <td>${post.Permalink ? `<a href="${post.Permalink}" target="_blank" style="color: var(--duke-blue); text-decoration: none; font-weight: bold;">üîó View</a>` : 'N/A'}</td>
                            </tr>`
                        ).join('')}
                    </tbody>
                </table>
            `;
            card.appendChild(tableContainer);
        }
        
        function generateEmailAnalytics(dashboard, startDate = null, endDate = null, compareType = 'none') {
            if (!processedData['Email_Campaign_Performance.csv']) return;
            
            let emailData = processedData['Email_Campaign_Performance.csv'];
            
            const container = document.createElement('div');
            container.className = 'dashboard';
            
            // Email Overview with Subscriber Metrics
            const overviewCard = createCard('üìä Email Campaign Overview & Subscriber Metrics');
            const metricsGrid = document.createElement('div');
            metricsGrid.className = 'metric-grid';
            
            const totalSent = emailData.reduce((sum, row) => sum + parseNumber(row['Emails sent']), 0);
            const totalDelivered = emailData.reduce((sum, row) => sum + parseNumber(row['Email deliveries']), 0);
            const totalOpened = emailData.reduce((sum, row) => sum + parseNumber(row['Email opened (MPP excluded)']), 0);
            const totalClicked = emailData.reduce((sum, row) => sum + parseNumber(row['Email clicked']), 0);
            const totalBounced = emailData.reduce((sum, row) => sum + parseNumber(row['Email bounces']), 0);
            const totalUnsubscribed = emailData.reduce((sum, row) => sum + parseNumber(row['Email unsubscribes']), 0);
            
            // Find unique email addresses (approximate subscriber count)
            const avgEmailsPerCampaign = totalSent / emailData.length;
            const estimatedSubscribers = Math.round(avgEmailsPerCampaign);
            
            const overallOpenRate = totalDelivered > 0 ? (totalOpened / totalDelivered) * 100 : 0;
            const overallClickRate = totalDelivered > 0 ? (totalClicked / totalDelivered) * 100 : 0;
            const overallBounceRate = totalSent > 0 ? (totalBounced / totalSent) * 100 : 0;
            const clickToOpenRate = totalOpened > 0 ? (totalClicked / totalOpened) * 100 : 0;
            
            // Calculate subscriber engagement percentages
            const nonOpeners = totalDelivered - totalOpened;
            const openersWhoDidntClick = totalOpened - totalClicked;
            const nonOpenerPercentage = totalDelivered > 0 ? (nonOpeners / totalDelivered) * 100 : 0;
            const openerNoClickPercentage = totalDelivered > 0 ? (openersWhoDidntClick / totalDelivered) * 100 : 0;
            
            metricsGrid.innerHTML = `
                ${createMetric(estimatedSubscribers, 'Est. Subscriber Count')}
                ${createMetric(totalSent.toLocaleString(), 'Total Emails Sent')}
                ${createMetric(overallOpenRate.toFixed(1) + '%', 'Overall Open Rate')}
                ${createMetric(overallClickRate.toFixed(1) + '%', 'Overall Click Rate')}
                ${createMetric(nonOpenerPercentage.toFixed(1) + '%', 'Never Opened %')}
                ${createMetric(openerNoClickPercentage.toFixed(1) + '%', 'Opened, No Click %')}
            `;
            
            overviewCard.appendChild(metricsGrid);
            
            // Add subscriber note
            const subscriberNote = document.createElement('div');
            subscriberNote.className = 'subscriber-note';
            subscriberNote.innerHTML = `
                <strong>üìä Subscriber Count Note:</strong> The estimated subscriber count (${estimatedSubscribers.toLocaleString()}) is based on the average emails sent per campaign. 
                Exact subscriber counts and demographics would require additional data from your email platform.
                <br><br>
                <strong>Engagement Breakdown:</strong><br>
                ‚Ä¢ Active Clickers: ${(overallClickRate).toFixed(1)}%<br>
                ‚Ä¢ Opened but didn't click: ${openerNoClickPercentage.toFixed(1)}%<br>
                ‚Ä¢ Never opened: ${nonOpenerPercentage.toFixed(1)}%
            `;
            overviewCard.appendChild(subscriberNote);
            
            container.appendChild(overviewCard);
            
            // Top Campaigns by Open Rate
            const topOpenCard = createCard('üèÜ Top 5 Campaigns by Open Rate');
            const topOpenCampaigns = emailData
                .filter(campaign => parseNumber(campaign['Emails sent']) > 100) // Filter out small campaigns
                .sort((a, b) => parsePercentage(b['Email open rate (MPP excluded)']) - parsePercentage(a['Email open rate (MPP excluded)']))
                .slice(0, 5);
            
            const openTableContainer = document.createElement('div');
            openTableContainer.className = 'table-container';
            openTableContainer.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Campaign</th>
                            <th>Open Rate</th>
                            <th>Opens</th>
                            <th>Sent</th>
                            <th>Delivered</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${topOpenCampaigns.map(campaign => 
                            `<tr>
                                <td><strong>${campaign.Campaign}</strong></td>
                                <td><strong style="color: var(--duke-blue);">${campaign['Email open rate (MPP excluded)']}</strong></td>
                                <td>${parseNumber(campaign['Email opened (MPP excluded)']).toLocaleString()}</td>
                                <td>${parseNumber(campaign['Emails sent']).toLocaleString()}</td>
                                <td>${parseNumber(campaign['Email deliveries']).toLocaleString()}</td>
                            </tr>`
                        ).join('')}
                    </tbody>
                </table>
            `;
            topOpenCard.appendChild(openTableContainer);
            container.appendChild(topOpenCard);
            
            // Top Campaigns by Click Rate
            const topClickCard = createCard('üéØ Top 5 Campaigns by Click Rate');
            const topClickCampaigns = emailData
                .filter(campaign => parseNumber(campaign['Emails sent']) > 100) // Filter out small campaigns
                .sort((a, b) => parsePercentage(b['Email click rate']) - parsePercentage(a['Email click rate']))
                .slice(0, 5);
            
            const clickTableContainer = document.createElement('div');
            clickTableContainer.className = 'table-container';
            clickTableContainer.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Campaign</th>
                            <th>Click Rate</th>
                            <th>Clicks</th>
                            <th>Total Clicks</th>
                            <th>CTR (Click-to-Open)</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${topClickCampaigns.map(campaign => 
                            `<tr>
                                <td><strong>${campaign.Campaign}</strong></td>
                                <td><strong style="color: var(--duke-blue);">${campaign['Email click rate']}</strong></td>
                                <td>${parseNumber(campaign['Email clicked']).toLocaleString()}</td>
                                <td>${parseNumber(campaign['Email total clicks']).toLocaleString()}</td>
                                <td>${campaign['Email clicks per unique opens (MPP excluded)'] || 'N/A'}</td>
                            </tr>`
                        ).join('')}
                    </tbody>
                </table>
            `;
            topClickCard.appendChild(clickTableContainer);
            container.appendChild(topClickCard);
            
            // Best Performing Links Note
            const linksCard = createCard('üîó Best-Performing Links Information');
            linksCard.innerHTML += `
                <div class="subscriber-note">
                    <strong>üìà Link Performance Data:</strong> Individual link click data (such as event registrations, donation pages, etc.) 
                    is not included in the standard email campaign export. 
                    <br><br>
                    <strong>To get this data:</strong><br>
                    ‚Ä¢ Check your email platform's link tracking reports<br>
                    ‚Ä¢ Look for UTM campaign data in Google Analytics<br>
                    ‚Ä¢ Export individual campaign link performance reports<br>
                    <br>
                    <strong>Available Metrics:</strong><br>
                    ‚Ä¢ Total link clicks across all campaigns: ${parseNumber(emailData.reduce((sum, row) => sum + parseNumber(row['Email total clicks']), 0)).toLocaleString()}<br>
                    ‚Ä¢ Average clicks per campaign: ${Math.round(parseNumber(emailData.reduce((sum, row) => sum + parseNumber(row['Email total clicks']), 0)) / emailData.length).toLocaleString()}
                </div>
            `;
            container.appendChild(linksCard);
            
            dashboard.appendChild(container);
        }
        
        function generateYouTubeAnalytics(dashboard, startDate = null, endDate = null, compareType = 'none') {
            const container = document.createElement('div');
            container.className = 'dashboard';
            
            // YouTube Overview
            if (processedData['YouTube_Content.csv']) {
                let content = processedData['YouTube_Content.csv'];
                
                if (startDate && endDate) {
                    const start = new Date(startDate);
                    const end = new Date(endDate);
                    content = content.filter(video => {
                        if (video['Video publish time']) {
                            const publishDate = new Date(video['Video publish time']);
                            return publishDate >= start && publishDate <= end;
                        }
                        return true;
                    });
                }
                
                const overviewCard = createCard('üé• YouTube Channel Overview');
                const metricsGrid = document.createElement('div');
                metricsGrid.className = 'metric-grid';
                
                const totalViews = content.reduce((sum, row) => sum + parseNumber(row.Views), 0);
                const totalWatchTime = content.reduce((sum, row) => sum + parseNumber(row['Watch time (hours)']), 0);
                const totalSubscribers = content.reduce((sum, row) => sum + parseNumber(row.Subscribers), 0);
                const totalImpressions = content.reduce((sum, row) => sum + parseNumber(row.Impressions), 0);
                const avgCTR = content.length > 0 ? 
                    content.reduce((sum, row) => sum + parseNumber(row['Impressions click-through rate (%)']), 0) / content.length : 0;
                const totalComments = content.reduce((sum, row) => sum + parseNumber(row['Comments added']), 0);
                const totalLikes = content.reduce((sum, row) => sum + parseNumber(row.Likes), 0);
                const totalShares = content.reduce((sum, row) => sum + parseNumber(row.Shares), 0);
                
                metricsGrid.innerHTML = `
                    ${createMetric(totalViews, 'Total Views')}
                    ${createMetric(Math.round(totalWatchTime), 'Watch Hours')}
                    ${createMetric(totalSubscribers, 'Subscribers Gained')}
                    ${createMetric(avgCTR.toFixed(1) + '%', 'Avg CTR')}
                    ${createMetric(totalImpressions, 'Total Impressions')}
                    ${createMetric(totalComments + totalLikes + totalShares, 'Total Engagement')}
                `;
                
                overviewCard.appendChild(metricsGrid);
                container.appendChild(overviewCard);
                
                // Demographics Section
                generateYouTubeDemographics(container);
                
                // Top Videos Analysis
                const topVideosCard = createCard('üèÜ Top 5 Videos by Performance');
                
                const tabContainer = document.createElement('div');
                tabContainer.className = 'tab-container';
                
                ['Views', 'Watch time (hours)', 'Likes', 'Comments added', 'Subscribers'].forEach((metric, index) => {
                    const tab = document.createElement('button');
                    tab.className = 'tab-button';
                    if (index === 0) tab.classList.add('active');
                    tab.textContent = `By ${metric === 'Comments added' ? 'Comments' : metric === 'Watch time (hours)' ? 'Watch Time' : metric}`;
                    tab.onclick = () => displayTopYouTubeVideos(metric, content, topVideosCard);
                    tabContainer.appendChild(tab);
                });
                
                topVideosCard.appendChild(tabContainer);
                displayTopYouTubeVideos('Views', content, topVideosCard);
                container.appendChild(topVideosCard);
            }
            
            // Subscriber vs Non-Subscriber Analysis
            if (processedData['YouTube_Subscription_Status.csv']) {
                const subData = processedData['YouTube_Subscription_Status.csv'];
                const subCard = createCard('üë• Viewer Analysis: Subscribers vs Non-Subscribers');
                
                const subMetricsGrid = document.createElement('div');
                subMetricsGrid.className = 'metric-grid';
                
                const subscriberData = subData.find(row => row['Subscription status'] === 'Subscribed') || {};
                const nonSubscriberData = subData.find(row => row['Subscription status'] === 'Not subscribed') || {};
                
                const subscriberViews = parseNumber(subscriberData.Views);
                const nonSubscriberViews = parseNumber(nonSubscriberData.Views);
                const totalSubViews = subscriberViews + nonSubscriberViews;
                
                const subscriberPercentage = totalSubViews > 0 ? (subscriberViews / totalSubViews) * 100 : 0;
                const nonSubscriberPercentage = totalSubViews > 0 ? (nonSubscriberViews / totalSubViews) * 100 : 0;
                
                subMetricsGrid.innerHTML = `
                    ${createMetric(subscriberPercentage.toFixed(1) + '%', 'Subscriber Views %')}
                    ${createMetric(nonSubscriberPercentage.toFixed(1) + '%', 'Non-Subscriber Views %')}
                    ${createMetric(subscriberViews.toLocaleString(), 'Subscriber Views')}
                    ${createMetric(nonSubscriberViews.toLocaleString(), 'Non-Subscriber Views')}
                `;
                
                subCard.appendChild(subMetricsGrid);
                
                const chartContainer = document.createElement('div');
                chartContainer.className = 'chart-container';
                const canvas = document.createElement('canvas');
                chartContainer.appendChild(canvas);
                subCard.appendChild(chartContainer);
                
                setTimeout(() => {
                    new Chart(canvas, {
                        type: 'pie',
                        data: {
                            labels: ['Subscribed Viewers', 'Non-Subscribed Viewers'],
                            datasets: [{
                                data: [subscriberViews, nonSubscriberViews],
                                backgroundColor: ['var(--duke-blue)', 'var(--duke-orange)']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        padding: 20,
                                        usePointStyle: true,
                                        font: {
                                            family: 'Montserrat'
                                        }
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Views by Subscription Status',
                                    font: {
                                        family: 'Montserrat',
                                        weight: 700,
                                        size: 16
                                    }
                                }
                            }
                        }
                    });
                }, 100);
                
                container.appendChild(subCard);
            }
            
            // Geographic Performance
            if (processedData['YouTube_Geography.csv']) {
                const geoData = processedData['YouTube_Geography.csv'];
                const geoCard = createCard('üåç Geographic Performance');
                
                const topCountries = geoData
                    .sort((a, b) => parseNumber(b.Views) - parseNumber(a.Views))
                    .slice(0, 10);
                
                const geoTableContainer = document.createElement('div');
                geoTableContainer.className = 'table-container';
                geoTableContainer.innerHTML = `
                    <table>
                        <thead>
                            <tr>
                                <th>Country/Region</th>
                                <th>Views</th>
                                <th>Watch Time (hrs)</th>
                                <th>Avg. Duration</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${topCountries.map(country => 
                                `<tr>
                                    <td><strong>${country.Geography}</strong></td>
                                    <td>${parseNumber(country.Views).toLocaleString()}</td>
                                    <td>${parseNumber(country['Watch time (hours)']).toLocaleString()}</td>
                                    <td>${country['Average view duration'] || 'N/A'}</td>
                                </tr>`
                            ).join('')}
                        </tbody>
                    </table>
                `;
                geoCard.appendChild(geoTableContainer);
                container.appendChild(geoCard);
            }
            
            dashboard.appendChild(container);
        }
        
        function generateYouTubeDemographics(container) {
            // Age and Gender Demographics
            if (processedData['YouTube_Age.csv'] || processedData['YouTube_Gender.csv']) {
                const demoCard = createCard('üë• YouTube Audience Demographics');
                
                // Age demographics
                if (processedData['YouTube_Age.csv']) {
                    const ageData = processedData['YouTube_Age.csv'];
                    
                    const ageChartContainer = document.createElement('div');
                    ageChartContainer.style.cssText = 'width: 100%; height: 250px; margin: 20px 0;';
                    const ageCanvas = document.createElement('canvas');
                    ageChartContainer.appendChild(ageCanvas);
                    demoCard.appendChild(ageChartContainer);
                    
                    setTimeout(() => {
                        new Chart(ageCanvas, {
                            type: 'bar',
                            data: {
                                labels: ageData.map(row => row['Viewer age']),
                                datasets: [{
                                    label: 'Views (%)',
                                    data: ageData.map(row => parseNumber(row['Views (%)'])),
                                    backgroundColor: 'var(--duke-blue)',
                                    borderRadius: 8,
                                    borderSkipped: false,
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    title: {
                                        display: true,
                                        text: 'Views by Age Group',
                                        font: {
                                            family: 'Montserrat',
                                            weight: 700,
                                            size: 16
                                        },
                                        color: 'var(--duke-navy)'
                                    },
                                    legend: {
                                        labels: {
                                            font: {
                                                family: 'Montserrat'
                                            }
                                        }
                                    }
                                },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        title: {
                                            display: true,
                                            text: 'Percentage of Views',
                                            font: {
                                                family: 'Montserrat',
                                                weight: 600
                                            }
                                        },
                                        ticks: {
                                            font: {
                                                family: 'Montserrat'
                                            }
                                        }
                                    },
                                    x: {
                                        ticks: {
                                            font: {
                                                family: 'Montserrat'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }, 100);
                }
                
                // Gender demographics
                if (processedData['YouTube_Gender.csv']) {
                    const genderData = processedData['YouTube_Gender.csv'];
                    
                    const genderGrid = document.createElement('div');
                    genderGrid.className = 'metric-grid';
                    genderGrid.style.marginTop = '25px';
                    
                    const genderMetrics = genderData.map(row => 
                        `<div class="metric">
                            <div class="metric-value">${parseNumber(row['Views (%)']).toFixed(1)}%</div>
                            <div class="metric-label">${row['Viewer gender']} Viewers</div>
                        </div>`
                    ).join('');
                    
                    genderGrid.innerHTML = genderMetrics;
                    demoCard.appendChild(genderGrid);
                }
                
                container.appendChild(demoCard);
            }
        }
        
        function displayTopYouTubeVideos(metric, content, card) {
            const existingTable = card.querySelector('.table-container');
            if (existingTable) {
                existingTable.remove();
            }
            
            const tabs = card.querySelectorAll('.tab-button');
            tabs.forEach((tab) => {
                tab.classList.remove('active');
                const tabMetric = tab.textContent.includes('Comments') ? 'Comments added' : 
                               tab.textContent.includes('Watch Time') ? 'Watch time (hours)' : 
                               tab.textContent.replace('By ', '');
                               
                if (tabMetric === metric || (tabMetric === 'Comments' && metric === 'Comments added') || 
                    (tabMetric === 'Watch Time' && metric === 'Watch time (hours)')) {
                    tab.classList.add('active');
                }
            });
            
            const topVideos = content
                .filter(video => parseNumber(video[metric]) > 0)
                .sort((a, b) => parseNumber(b[metric]) - parseNumber(a[metric]))
                .slice(0, 5);
            
            if (topVideos.length === 0) {
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'no-data-message';
                noDataDiv.innerHTML = `üì≠ No videos found with ${metric} data for the selected time period.`;
                card.appendChild(noDataDiv);
                return;
            }
            
            const tableContainer = document.createElement('div');
            tableContainer.className = 'table-container';
            tableContainer.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Video Title</th>
                            <th>${metric === 'Comments added' ? 'Comments' : metric === 'Watch time (hours)' ? 'Watch Time (hrs)' : metric}</th>
                            <th>Views</th>
                            <th>Likes</th>
                            <th>CTR (%)</th>
                            <th>Subscribers</th>
                            <th>Link</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${topVideos.map(video => 
                            `<tr>
                                <td><strong>${(video['Video title'] || '').substring(0, 40)}...</strong></td>
                                <td><strong style="color: var(--duke-blue);">${metric === 'Watch time (hours)' ? 
                                    Math.round(parseNumber(video[metric])) : 
                                    parseNumber(video[metric]).toLocaleString()}</strong></td>
                                <td>${parseNumber(video.Views || 0).toLocaleString()}</td>
                                <td>${parseNumber(video.Likes || 0).toLocaleString()}</td>
                                <td>${parseNumber(video['Impressions click-through rate (%)'] || 0).toFixed(1)}%</td>
                                <td>+${parseNumber(video.Subscribers || 0).toLocaleString()}</td>
                                <td>${video.Content ? `<a href="https://www.youtube.com/watch?v=${video.Content}" target="_blank" style="color: var(--duke-blue); text-decoration: none; font-weight: bold;">üîó View</a>` : 'N/A'}</td>
                            </tr>`
                        ).join('')}
                    </tbody>
                </table>
            `;
            card.appendChild(tableContainer);
        }
        
        function createMetric(value, label) {
            return `
                <div class="metric">
                    <div class="metric-value">${typeof value === 'number' ? value.toLocaleString() : value}</div>
                    <div class="metric-label">${label}</div>
                </div>
            `;
        }
        
        function createCard(title) {
            const card = document.createElement('div');
            card.className = 'card';
            
            const header = document.createElement('h3');
            header.textContent = title;
            card.appendChild(header);
            
            return card;
        }
        
        function updateDashboard() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            const compareType = document.getElementById('compareType').value;
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            
            if (startDate && endDate) {
                const startDateObj = new Date(startDate);
                const endDateObj = new Date(endDate);
                const daysDiff = Math.ceil((endDateObj - startDateObj) / (1000 * 60 * 60 * 24)) + 1;
                
                const dataRange = getDataDateRange();
                let rangeText = `üìÖ Showing ${daysDiff} days: ${startDateObj.toLocaleDateString()} - ${endDateObj.toLocaleDateString()}`;
                if (dataRange.min && dataRange.max) {
                    rangeText += ` (Available: ${dataRange.min.toLocaleDateString()} - ${dataRange.max.toLocaleDateString()})`;
                }
                
                dateRangeInfo.innerHTML = rangeText;
                generateDashboard(startDate, endDate, compareType);
            } else {
                generateDashboard();
            }
        }
    </script>
</body>
</html>